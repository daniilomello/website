---
title: "Git Flow, Conventional Commit and Semantic Versioning"
publishedAt: "2025-04-05"
summary: "A practical overview of Git Flow, Conventional Commits, and Semantic Versioning working together."
category: "code"
language: "ðŸ‡ºðŸ‡¸"
image: ""
---

## Introduction

Git Flow is a branching model that helps teams manage and streamline collaborative development. It defines structured workflows to create, manage, and merge branches effectively, ensuring a well-organized development process and a stable production environment.

This guide will introduce Git Flow, Conventional Commits, and Semantic Versioning, which together create a standardized and efficient workflow for software development.

## Git Flow

Git Flow organizes development into different branches, each with a specific purpose. This structure allows multiple developers to work on features concurrently while keeping the main branch stable.

### Branches in Git Flow

- `main`: Stores the production-ready code.
- `develop`: The integration branch where ongoing development takes place.
- `feature`: Dedicated to developing new features before merging into `develop`.
- `release`: Prepares new versions for deployment.
- `hotfix`: Used for urgent bug fixes in production.

### Setting Up Git Flow

To initialize Git Flow in a repository:

```bash
git flow init
```

Creating a new feature branch:

```bash
git flow feature start feature-name
```

Merging and deleting the feature branch:

```bash
git flow feature finish feature-name
```

Creating a release branch:

```bash
git flow release start version-number
```

Finalizing a release:

```bash
git flow release finish version-number
```

## Conventional Commits

Conventional Commits establish a consistent structure for commit messages, making it easier to understand the history of changes, automate versioning, and generate changelogs.

### Commit Message Format

```text
[optional scope]:
[optional body]
[optional footer]
```

### Common Commit Types

- `feat`: Adds a new feature.
- `fix`: Fixes a bug.
- `chore`: Changes that do not affect the code (e.g., configurations).
- `docs`: Documentation updates.
- `style`: Formatting changes without altering logic.
- `refactor`: Code improvements without changing behavior.
- `test`: Adds or updates tests.
- `BREAKING CHANGE`: Indicates a breaking change (can also be marked with `!` in the type).

### Example Commits

```text
feat(auth): add JWT authentication
fix(cart): resolve issue with item removal
chore: update CI/CD pipeline configuration
```

## Semantic Versioning

Semantic Versioning (SemVer) provides a standardized way to assign version numbers to software releases, making updates predictable and ensuring compatibility across dependencies.

### Version Number Format: MAJOR.MINOR.PATCH

Each segment has a specific meaning:

- **MAJOR** (`X.0.0`): Introduces breaking changes requiring updates to dependent code.
- **MINOR** (`0.Y.0`): Adds new features without breaking compatibility.
- **PATCH** (`0.0.Z`): Introduces bug fixes or small improvements that maintain compatibility.

### Example Versioning

- `1.0.0`: Initial stable release.
- `1.1.0`: Added a new feature without breaking changes.
- `1.1.1`: Fixed a bug without modifying functionality.
- `2.0.0`: Major update requiring code changes.

### Pre-Release Labels

- Alpha (`-alpha`): Early-stage testing, unstable.
- Beta (`-beta`): More stable but still subject to changes.
- Release Candidate (`-rc`): Final pre-release testing.
- Stable: Official, production-ready release (e.g., `1.0.0`).

## Conclusion

Using Git Flow, Conventional Commits, and Semantic Versioning together ensures an organized and predictable development process. These best practices enhance collaboration, reduce errors, and streamline version management, leading to more maintainable and professional software development.

By following these guidelines, you can improve your teamâ€™s efficiency and maintain a clean and structured project history.

If this post helped you, share it with a friend or post it on social media.

Thank you for reading!
