---
title: "Criando uma API na AWS com Serverless Framework"
publishedAt: "2025-10-04"
summary: "Introdu√ß√£o ao Serverless Framework v4 criando uma API HTTP na AWS com Lambda, API Gateway e DynamoDB."
category: "code"
language: "üáßüá∑"
image: ""
---

## Introdu√ß√£o

Nesse artigo vamos fazer uma introdu√ß√£o ao Serverless Framework na vers√£o 4 como uma ferramenta de IaC para criarmos uma infraestrutura na AWS de forma r√°pida sem gerenciar os recurso manualmente no console, ou escrever grande scripts para ferrametas de IaC nativas como CloudFormation ou Terraform.

Eu n√£o irei detalhar o que cada item faz, o objetivo √© mostrar como √© r√°pido e f√°cil subir um ambiente na AWS com o Serverless Framework.

## Requisitos

Para seguir com esse artigo, √© importante que voc√™ preencha os requistos a seguir:

- Ter instalado o Serverless Framework (`npm install -g serverless`)
- Ter configurado a CLI da AWS na sua maquina
- Ter uma conta ativa na AWS
- Ter o Node.js instalado

## O que √© Serverless Framework

Ele √© uma ferramenta que abstrai a complexidade dos servi√ßos nativos da nuvem como o CloudFormation da AWS, permitindo que voc√™ gerencie sua arquitetura de forma elegante e concisa.

Diferente de outras ferramentas, ele, al√©m de gerenciar sua infraestrutura, tamb√©m gerencia o seu c√≥digo. Outro ponto, √© que ele suporta diferentes tipos de linguagens como Python, Node.js e Go.

## Fun√ß√µes, eventos e recursos

O Serverless Framework √© gerenciado em arquivo de servi√ßo chamado: `serverless.yml` nele voc√™ controla os seus recursos, fun√ß√µes e eventos, funcionando da seguinte maneira:

O c√≥digo √© lan√ßado e executado na AWS como uma **fun√ß√£o lambda**. Cada fun√ß√£o √© subida e executada individualmente com uma √∫nica responsabilidade, funcionando quase como um microservi√ßo. Por exemplo: uma fun√ß√£o para salvar o usu√°rio em um banco de dados.

Essas fun√ß√µes s√£o disparadas atrav√©s de **eventos** que vem de recursos da AWS. Por exemplo: quando uma requisi√ß√£o HTTP √© feita no API Gateway, uma lambda √© disparada.

As fun√ß√µes criadas podem precisar de um **recursos** da AWS, como um banco de dados, um bucket de armazenamento, um bucket de arquivos, etc. Dentro do Serverless √© poss√≠vel provisionar esses recursos.

## Come√ßando nossa API

Para usar os comandos serverless na vers√£o 4, √© necess√°rio fazer o login na plataforma, ent√£o crie uma conta e utilize o comando a seguir:

```bash
serverless login
```

Vamos come√ßar criando um novo projeto. Uma vez que voc√™ digitar o comando abaixo, ser√° necess√°rio escolher uma op√ß√£o, vamos seguir com: ‚ÄúAWS ‚Äì Node.js ‚Äì HTTP API‚Äù.

Depois, escolha um nome para o projeto, no meu caso estarei usando o nome: `customers-api`.

Por fim, ele deve pedir para voc√™ vincular esse projeto a um app da dashboard, pode selecionar o ‚ÄòSkip Adding an App‚Äô e continuar.

```bash
serverless
```

Uma vez que o projeto foi iniciado, vamos entrar na pasta e instalar as deped√™ncias necess√°rias:

```bash
cd customers-api
npm install
```

O deploy dos servi√ßos podem demorar um pouco, ent√£o mesmo que nenhuma fun√ß√£o tenha sido criada, vamos fazer o primeiro deploy com a estrutura inicial da nossa API.

A partir de agora vamos usar a abrevia√ß√£o do comando serverless como `sls`.

```bash
sls deploy
```

_Se tiver algum tipo de problema com o deploy, revise suas configura√ß√µes de CLI da AWS e tente novamente os passos anteriores._

Agora vamos testar nosso endpoint para ver se esta funcionando corretamente.

_Lembre-se de utilizar a sua URL._

```bash
curl https://zxwwdsj8ol.execute-api.us-east-1.amazonaws.com/
# output
# {"message":"Go Serverless v4! Your function executed successfully!"}
```

## Criando os endpoints e organizando o projeto

Antes de atualizar o arquivo `serverless.yml`, vamos criar os endpoints da nossa aplica√ß√£o.

Eu gosto de organizar o projeto colocando as fun√ß√µes dentro de uma `src`. Dentro dela, vamos nossa primeira fun√ß√£o chamada `createCustomer.js` que ir√° salvar um novo cliente no nosso banco de dados usando o DynamoDB.

Para facilitar nosso desenvolvimento vamos instalar os pacotes da AWS.

```bash
npm install @aws-sdk/client-dynamodb @aws-sdk/lib-dynamodb
```

Agora vamos criar o arquivo `createCustomer.js`.

```javascript
"use strict";
const { DynamoDBClient } = require("@aws-sdk/client-dynamodb");
const { DynamoDBDocumentClient, PutCommand } = require("@aws-sdk/lib-dynamodb");

module.exports.handler = async (event) => {
  const body = JSON.parse(Buffer.from(event.body, "base64").toString());

  const ddb = DynamoDBDocumentClient.from(new DynamoDBClient({}));
  const putParams = {
    TableName: process.env.DYNAMODB_CUSTOMER_TABLE,
    Item: {
      primary_key: body.name,
      email: body.email,
    },
  };

  await ddb.send(new PutCommand(putParams));

  return {
    statusCode: 201,
  };
};
```

Agora vamos criar o arquivo para exibir a lista de clientes `getCustomers.js`.

```javascript
"use strict";
const { DynamoDBClient } = require("@aws-sdk/client-dynamodb");
const { DynamoDBDocumentClient, ScanCommand } = require("@aws-sdk/lib-dynamodb");

module.exports.handler = async () => {
  const ddb = DynamoDBDocumentClient.from(new DynamoDBClient({}));
  const result = await ddb.send(
    new ScanCommand({
      TableName: process.env.DYNAMODB_CUSTOMER_TABLE,
    })
  );

  if (!result.Count || result.Count === 0) {
    return {
      statusCode: 404,
    };
  }

  return {
    statusCode: 200,
    body: JSON.stringify({
      total: result.Count,
      items: result.Items.map((customer) => ({
        name: customer.primary_key,
        email: customer.email,
      })),
    }),
  };
};
```

## Atualizando o arquivo `serverless.yml`

Agora vamos atualizar o arquivo `serverless.yml` adicionando os endpoints e recursos necess√°rios.

Nosso `serverless.yml` deve come√ßar da seguinte igual o arquivo abaixo, caso seu esteja diferente fa√ßa as modifica√ß√µes:

```yaml
org: daniilomello
service: customers-api

provider:
  name: aws
  runtime: nodejs20.x
  architecture: arm64

package:
  individually:
```

Agora vamos adicionar os endpoints, que s√£o fun√ß√µes lambdas integradas com o API Gateway. Para isso vamos adicionar o seguinte:

```yaml
functions:
  createCustomer:
    handler: src/createCustomer.handler
    events:
      - httpApi:
          path: /customers
          method: post
  getCustomers:
    handler: src/getCustomers.handler
    events:
      - httpApi:
          path: /customers
          method: get
```

Agora vamos adicionar o nosso recuso do DynamoDB para usarmos como banco de dados:

```yaml
resources:
  Resources:
    CustomerTable:
      Type: AWS::DynamoDB::Table
      Properties:
        AttributeDefinitions:
          - AttributeName: primary_key
            AttributeType: S
        BillingMode: PAY_PER_REQUEST
        KeySchema:
          - AttributeName: primary_key
            KeyType: HASH
        TableName: CustomerTable
```

Para que as nossas fun√ß√µes tenham permiss√£o de realizar opera√ß√µes no nosso banco de dados, precisamos configura o IAM da AWS no nosso provider. Para isso fa√ßa o seguite:

```yaml
provider:
  iam:
    role:
      statements:
        - Effect: "Allow"
          Action:
            - "dynamodb:PutItem"
            - "dynamodb:Get*"
            - "dynamodb:Scan*"
            - "dynamodb:UpdateItem"
            - "dynamodb:DeleteItem"
          Resource: !GetAtt CustomerTable.Arn
```

Al√©m disso, nossas fun√ß√µes chamam o nome da tabela atrav√©s de uma vari√°vel de ambiente. Vamos configura essa vari√°vel dentro do nosso provider:

```yaml
provider:
  environment:
    DYNAMODB_CUSTOMER_TABLE: !Ref CustomerTable
```

Nosso arquivo final `yml` deve ficar da seguinte forma:

```yaml
org: daniilomello
service: customers-api

provider:
  name: aws
  runtime: nodejs20.x
  architecture: arm64
  environment:
    DYNAMODB_CUSTOMER_TABLE: !Ref CustomerTable
  iam:
    role:
      statements:
        - Effect: "Allow"
          Action:
            - "dynamodb:PutItem"
            - "dynamodb:Get*"
            - "dynamodb:Scan*"
            - "dynamodb:UpdateItem"
            - "dynamodb:DeleteItem"
          Resource: !GetAtt CustomerTable.Arn

package:
  individually: true

custom:
  esbuild:
    bundle: true
    minify: false
    sourcemap: false
    exclude:
      - "@aws-sdk/*"
    target: node20

functions:
  createCustomer:
    handler: src/createCustomer.handler
    events:
      - httpApi:
          path: /customers
          method: post
  getCustomers:
    handler: src/getCustomers.handler
    events:
      - httpApi:
          path: /customers
          method: get

resources:
  Resources:
    CustomerTable:
      Type: AWS::DynamoDB::Table
      Properties:
        AttributeDefinitions:
          - AttributeName: primary_key
            AttributeType: S
        BillingMode: PAY_PER_REQUEST
        KeySchema:
          - AttributeName: primary_key
            KeyType: HASH
        TableName: CustomerTable
```

Agora que est√° tudo configurado, vamos testar criar um novo cliente, e exibir a lista de clientes.

_Lembre-se de utilizar a sua URL._

Criando um cliente:

```bash
curl -X POST -d '{"name":"Danilo Mello","email":"mello@daniilo.dev"}' --url https://zxwwdsj8ol.execute-api.us-east-1.amazonaws.com/customers
# output
# {"statusCode":201}%
```

Listando os clientes:

```bash
curl --url https://zxwwdsj8ol.execute-api.us-east-1.amazonaws.com/customers
# output
# {"total":1,"items":[{"name":"Danilo Mello","email":"mello@daniilo.dev"}]}%
```

## Conclus√£o

Nesse artigo voc√™ viu como √© rapido e simples subir um ambiente na AWS com o Serverless Framework.

Agora com o Serverless Framework voc√™ consegue:

- Fazer o deploy da sua infraestrutura por linha de comando
- Criar permiss√µes usando o IAM
- Criar fun√ß√µes lambdas na AWS
- Criar bancos de dados no DynamoDB
- Criar APIs com o API Gateway

Agora vai de voc√™ explorar e se aprofundar mais nessa ferramenta.
