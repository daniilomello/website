---
title: "Aplicando os princ√≠pios de SOLID no React."
publishedAt: "2026-02-06"
summary: "Uma adapta√ß√£o pr√°tica dos princ√≠pios SOLID para componentes e hooks em React, com exemplos e refatora√ß√µes."
category: "code"
language: "üáßüá∑"
image: ""
---

Robert C. Martins criou cinco princ√≠pios de design de softwares com o objetivo de tornar um c√≥digo, mais leg√≠vel, sustent√°vel e test√°vel. Esses princ√≠pios s√£o conhecidos como SOLID. 

Inicialmente, esses princ√≠pios foram pensados para a programa√ß√£o orientada a objetos, mas hoje eu quero trazer uma adapta√ß√£o para o ecossistema do React, pensando em componentes e hooks. 

Antes de fazermos o todo list mais robusto de todos os tempos, lembre-se de que s√£o sugest√µes e princ√≠pios que precisam ser considerados com cuidado ao serem aplicados no seu projeto.

N√£o precisa sair aplicando todos os princ√≠pios em todos os componentes e refatorando tudo. Ok?

## Single Responsibility Principle (SRP)

Na defini√ß√£o original desse princ√≠pio, √© dita que uma classe deve ter apenas uma raz√£o para mudar. No contexto do React, a regra √© que cada componente, hook ou fun√ß√£o deve fazer apenas uma √∫nica coisa.

Para verificar se seu componente ou hook viola este princ√≠pio, se pergunte:

- Este componente deve mostrar a UI ou lidar com os dados?
- Qual tipo √∫nico de dados este hook deve manipular?
- Pertence a camada de armazenamento de dados ou UI?

Se o hook ou o componente n√£o tiver uma resposta √∫nica para essas perguntas, ele est√° violando o princ√≠pio. Procure separar a l√≥gica da apresenta√ß√£o visual. Coloque a l√≥gica em hooks com responsabilidades √∫nicas e separe componentes de forma isolada.

Componentes e hooks que seguem este princ√≠pio s√£o mais propensos a serem reutiliz√°veis, mais f√°ceis de serem testados e de manter. S√£o componentes e elementos   desacoplados que evitam conflitos.

A seguir temos um exemplo de c√≥digo ruim que viola o SRP. Neste exemplo, o componente `TodoList` faz quatro coisas ao mesmo tempo: gerencia o estado da lista, faz a chamada para a API, cont√©m a l√≥gica de filtragem e define toda a interface visual.

```tsx
// TodoListBAD.tsx
import React, { useState, useEffect, useMemo } from 'react';
import axios from 'axios';

export function TodoList() {
  const [todos, setTodos] = useState<any[]>([]);
  const [filter, setFilter] = useState('all');

  // Responsabilidade 1: Buscar dados da API
  useEffect(() => {
    axios.get('https://api.exemplo.com/todos').then(res => setTodos(res.data));
  }, []);

  // Responsabilidade 2: L√≥gica de filtragem
  const filteredTodos = useMemo(() => {
    return todos.filter(todo => 
      filter === 'all' ? true : todo.status === filter
    );
  }, [todos, filter]);

  // Responsabilidade 3 e 4: Renderizar UI de filtro e Lista de itens
  return (
    <div>
      <h1>Minhas Tarefas</h1>
      <select onChange={(e) => setFilter(e.target.value)}>
        <option value="all">Todas</option>
        <option value="completed">Conclu√≠das</option>
      </select>

      <ul>
        {filteredTodos.map(todo => (
          <li key={todo.id} style={{ padding: '10px', borderBottom: '1px solid #ccc' }}>
            <input type="checkbox" checked={todo.completed} readOnly />
            <span>{todo.title}</span>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

Agora vamos refatorar esse c√≥digo, aplicando o SRP. Para aplicar o SRP, devemos quebrar o componente grande em partes menores com responsabilidades √∫nicas.

Primeiro, lidamos com a l√≥gica. Extra√≠mos a busca de dados e o gerenciamento de estado para um hook personalizado.

```tsx
// useTodos.ts
export function useTodos() {
  const [todos, setTodos] = useState([]);
  useEffect(() => {
    axios.get('https://api.exemplo.com/todos').then(res => setTodos(res.data));
  }, []);
  return todos;
}
```

Segundo, criamos componentes para lidar apenas com a exibi√ß√£o, lidando com a parte visual.

```tsx
// TodoItem.tsx (Apenas renderiza um √∫nico item)
export function TodoItem({ todo }: { todo: any }) {
  return (
    <li className="todo-item">
      <input type="checkbox" checked={todo.completed} readOnly />
      <span>{todo.title}</span>
    </li>
  );
}

// TodoFilter.tsx (Apenas lida com a mudan√ßa de filtro)
export function TodoFilter({ onFilterChange }: { onFilterChange: (f: string) => void }) {
  return (
    <select onChange={(e) => onFilterChange(e.target.value)}>
      <option value="all">Todas</option>
      <option value="completed">Conclu√≠das</option>
    </select>
  );
}
```

Por fim, criamos o componente principal, que **comp√µe** as pe√ßas, tornando-o muito mais leg√≠vel e f√°cil de manter.

```tsx
// TodoListGOOD.tsx
export function TodoList() {
  const todos = useTodos(); // Hook especializado
  const [filter, setFilter] = useState('all');

  const filteredTodos = todos.filter(t => filter === 'all' || t.status === filter);

  return (
    <div>
      <h1>Minhas Tarefas</h1>
      <TodoFilter onFilterChange={setFilter} />
      <ul>
        {filteredTodos.map(todo => (
          <TodoItem key={todo.id} todo={todo} />
        ))}
      </ul>
    </div>
  );
}
```

Com essa refatora√ß√£o, temos um componente `TodoItem` e um hook `useTodos`, que podem ser usados em outras partes da aplica√ß√£o. 

O hook `useTodos` ficou simples de ser testado, tendo sua l√≥gica separada da renderiza√ß√£o do componente. 

Ambos, componente e hook, podem ser atualizados e mantidos sem problemas de conflito, mudando a estiliza√ß√£o ou a API utilizada.
## Open/Closed Principle (OCP)

A ideia desse princ√≠pio √© que componentes, hooks e fun√ß√µes devem estar abertos para extens√£o, mas fechados para modifica√ß√µes.

No contexto do React, isso significa que voc√™ deve ser capaz de adicionar novas funcionalidades ou varia√ß√µes visuais a um componente sem modificar o c√≥digo original dele.

Na pr√°tica, pensando em componentes, esse princ√≠pio pode ser aplicado utilizando props para manipular os componentes, fazer uma personaliza√ß√£o ou extens√£o do mesmo, ou a cria√ß√£o de componentes seguindo o padr√£o de compound components.

No caso dos hooks, podemos usar a cria√ß√£o de hooks personalizados que chamam outros hooks sem precisar manipular o c√≥digo original do hook a ser utilizado.

Ainda utilizando o nosso Todo List, a seguir temos um exemplo ruim, que viola o OCP. Aqui, o componente `TodoItem` tenta lidar com todos os tipos poss√≠veis de tarefas internamente. Se amanh√£ surgir um novo tipo de tarefa, voc√™ precisar√° modificar este arquivo, correndo o risco de quebrar os tipos que j√° funcionam.

```tsx
// TodoItemBAD.tsx
import React from 'react';

type TodoType = 'simple' | 'deadline' | 'link';

interface Todo {
  id: number;
  type: TodoType;
  title: string;
  completed: boolean;
  meta?: any; // Dados extras (data, url, etc)
}

export function TodoItem({ todo, onToggle }: { todo: Todo; onToggle: () => void }) {
  return (
    <li className="todo-item">
      <input type="checkbox" checked={todo.completed} onChange={onToggle} />
      
      {/* VIOLA√á√ÉO OCP: L√≥gica condicional r√≠gida dentro do componente */}
      <div className="content">
        <span>{todo.title}</span>
        
        {todo.type === 'deadline' && (
          <span className="date"> üìÖ {todo.meta.dueDate}</span>
        )}
        
        {todo.type === 'link' && (
          <a href={todo.meta.url} className="link"> üîó Abrir Link</a>
        )}
        
        {/* Se precisarmos de um tipo 'shopping', teremos que editar este arquivo e adicionar mais um IF */}
      </div>
    </li>
  );
}
```

Agora vamos refatorar este c√≥digo aplicando o princ√≠pio de OCP. Primeiro, transformamos o `TodoItem` em um componente base gen√©rico que aceita conte√∫do din√¢mico atrav√©s de um children ou props. Assim, ele fica fechado para modifica√ß√µes, mas aberto para extens√£o/personaliza√ß√£o.

```tsx
// TodoItemBase.tsx
import React, { ReactNode } from 'react';

interface TodoItemBaseProps {
  completed: boolean;
  onToggle: () => void;
  children: ReactNode; // Ponto de extens√£o
}

export function TodoItemBase({ completed, onToggle, children }: TodoItemBaseProps) {
  return (
    <li className="todo-item">
      <input type="checkbox" checked={completed} onChange={onToggle} />
      <div className="content">
        {children} 
      </div>
    </li>
  );
}
```

Agora, criamos componentes que usam a base, e se um novo tipo de tarefa surgir, criamos um novo arquivo ao inv√©s de alterar o antigo.

```tsx
// TodoItemVariants.tsx

// Tarefa Simples
export function SimpleTodoItem({ todo, onToggle }: { todo: any; onToggle: () => void }) {
  return (
    <TodoItemBase completed={todo.completed} onToggle={onToggle}>
      <span>{todo.title}</span>
    </TodoItemBase>
  );
}

// Tarefa com Prazo (Extens√£o 1)
export function DeadlineTodoItem({ todo, onToggle }: { todo: any; onToggle: () => void }) {
  return (
    <TodoItemBase completed={todo.completed} onToggle={onToggle}>
      <span>{todo.title}</span>
      <span className="date" style={{ color: 'red', marginLeft: '10px' }}>
        üìÖ Vence em: {todo.meta.dueDate}
      </span>
    </TodoItemBase>
  );
}

// Tarefa com Link (Extens√£o 2)
export function LinkTodoItem({ todo, onToggle }: { todo: any; onToggle: () => void }) {
  return (
    <TodoItemBase completed={todo.completed} onToggle={onToggle}>
      <span>{todo.title}</span>
      <a href={todo.meta.url} target="_blank" style={{ marginLeft: '10px' }}>
        üîó Acessar
      </a>
    </TodoItemBase>
  );
}
```

Por fim, na lista principal escolhemos qual componente renderizar. Mesmo que tenha um l√≥gica utilizando o switch, n√£o estamos violando o SRP, pois essa √© uma camada de composi√ß√£o, e n√£o de apresenta√ß√£o. 

```tsx
// TodoList.tsx
export function TodoList() {
  const todos = useTodos(); // Hook do exemplo anterior

  const renderTodoItem = (todo: any) => {
    switch (todo.type) {
      case 'deadline':
        return <DeadlineTodoItem key={todo.id} todo={todo} onToggle={() => {}} />;
      case 'link':
        return <LinkTodoItem key={todo.id} todo={todo} onToggle={() => {}} />;
      default:
        return <SimpleTodoItem key={todo.id} todo={todo} onToggle={() => {}} />;
    }
  };

  return (
    <ul>
      {todos.map(renderTodoItem)}
    </ul>
  );
}
```

Com esta refatora√ß√£o, n√≥s temos mais flexibilidade, e o design de cada tipo de tarefa pode ser diferente. O componente `TodoItemBase` fica limpo, focando apenas na estrutura.
 
Temos mais seguran√ßa, pois podemos criar um componente novo como `ShoppingTodoItem` sem medo de quebrar a l√≥gica de exibi√ß√£o no `LinkTodoItem`.
## Liskov Substitution Principle (LSP)

Esse princ√≠pio diz que objetos subtipos devem ser substitu√≠veis por objetos supertipos. 

Isso pode ser aplicado no React utilizando o TypeScript. Ao utilizar interfaces (interface) e extens√£o de tipos (extends), e for√ßar o contrato de que o subtipo deve possuir todas as propriedades do supertipo

A ideia √© ter a capacidade de trocar componentes ou hooks por outros do mesmo tipo sem quebrar a aplica√ß√£o. Se um componente/hook aceita certas props (entradas), todos os componentes/hooks que o estendem ou substituem devem aceitar as mesmas props e retornar valores compat√≠veis.

A seguir temos um exemplo de componente que viola o princ√≠pio LSP, pois ele renomeia um evento padr√£o e limita a quantidade de props aceitas. Se uma prop como "placeholder" for passada, o componente quebrar√° ou ignorar√°, pois ele n√£o espera receber essa prop.

```tsx
// TaskInputBAD.tsx
import React from 'react';

// Define uma interface restrita e propriet√°ria
interface TaskInputProps {
  val: string;
  onTextChange: (text: string) => void; // Viola√ß√£o: Renomeando comportamento padr√£o
}

export function TaskInputBad({ val, onTextChange }: TaskInputProps) {
  return (
    <input 
      type="text"
      className="border p-2 rounded"
      value={val}
      // Viola√ß√£o: A l√≥gica interna for√ßa uma assinatura diferente da nativa
      onChange={(e) => onTextChange(e.target.value)}
    />
  );
}

// Uso na TodoList:
<TaskInputBad val={text} onTextChange={setText} /> 
// Se tentarmos adicionar placeholder="Nova tarefa", vai dar erro de TypeScript/Runtime.
```

Agora vamos refatorar esse c√≥digo aplicando o princ√≠pio de LSP. Primeiro vamos estender a interface nativa `InputHTMLAttributes.` Depois usamos o spred operator para garantir que qualquer prop padr√£o (ex: placeholder) funcione corretamente.

```tsx
// TaskInputGOOD.tsx
import React, { InputHTMLAttributes } from 'react';

// Estendemos a interface nativa do input.
// O componente agora √© um "subtipo" v√°lido de um HTMLInputElement
interface TaskInputProps extends InputHTMLAttributes<HTMLInputElement> {
  label?: string; // Podemos estender com novas props (Open-Closed Principle)
}

export function TaskInputGood({ label, className, ...props }: TaskInputProps) {
  return (
    <div className="flex flex-col gap-1">
      {label && <label className="text-sm font-bold text-gray-700">{label}</label>}
      <input
        className={`border p-2 rounded focus:outline-blue-500 ${className || ''}`}
        {...props} // Repassa todas as props nativas (Princ√≠pio de Liskov)
      />
    </div>
  );
}
```

Agora que nosso componente segue o padr√£o LSP, podemos usar eventos de teclado (`onKeyDown`) e atributos de acessibilidade (`aria-label`) que n√£o foram explicitamente declarados no nosso componente, mas funcionam porque respeitamos o contrato base que ele utiliza. 

```tsx
// TodoList.tsx
import React, { useState } from 'react';
import { TaskInputGood } from './TaskInputGOOD';

export function TodoList() {
  const [text, setText] = useState('');
  const [todos, setTodos] = useState<string[]>([]);

  const handleAdd = () => {
    if (text) {
      setTodos([...todos, text]);
      setText('');
    }
  };

  return (
    <div>
      <h1>Minhas Tarefas</h1>
      
      {/* Aqui aplicamos o LSP: Estamos usando props nativas (placeholder, onKeyDown)
         que o TaskInputGood aceita naturalmente por estender o input padr√£o.
      */}
      <TaskInputGood
        label="Nova Tarefa"
        value={text}
        onChange={(e) => setText(e.target.value)}
        placeholder="Digite e pressione Enter..."
        autoFocus
        onKeyDown={(e) => {
          if (e.key === 'Enter') handleAdd();
        }}
      />

      <ul style={{ marginTop: '20px' }}>
        {todos.map((todo, index) => (
          <li key={index}>{todo}</li>
        ))}
      </ul>
    </div>
  );
}
```

 Com essa refatora√ß√£o, ganhamos previsibilidade. Devs do time sabem utilizar o nosso componente e n√£o precisam aprender sobre eventos novos. Tamb√©m ganhamos flexibilidade, pois nosso componente tem suporte nativo a propriedades que podem ser valiosas para n√≥s no futuro e j√° funciona automaticamente.
## Interface Segregation Principle (ISP)

A ideia original desse princ√≠pio √© que clientes n√£o devem ser for√ßados a depender de interfaces que n√£o utilizam. No caso do React, podemos pensar que componentes n√£o devem receber props que n√£o utilizam. 

√â muito comum passar um objeto inteiro para dentro do componente quando ele precisa apenas de um √∫nico elemento, √†s vezes definindo as propriedades como opcionais, mas o ideal √© que seja passado apenas aquilo que √© essencial. 

No exemplo a seguir, temos um componente que viola o ISP, nele passamos um objeto `todo` inteiro para os componentes filhos, mesmo com eles precisando apenas do `title`, criamo um acoplamento desnecess√°rio.

```tsx
// Defini√ß√£o do objeto Todo completo
interface Todo {
  id: string;
  title: string;
  description: string;
  isCompleted: boolean;
  createdAt: Date;
  userId: string; // Dados extras que componentes visuais n√£o precisam saber
}

// O componente 'TodoTitle' recebe o objeto inteiro, 
// mas s√≥ usa o 'title'. Ele "conhece" dados que n√£o deveria (userId, id, etc).
const TodoTitle = ({ todo }: { todo: Todo }) => {
  return <h1>{todo.title}</h1>;
};

// O componente 'TodoDate' recebe tudo, mas s√≥ usa 'createdAt'.
const TodoDate = ({ todo }: { todo: Todo }) => {
  return <span>Criado em: {todo.createdAt.toLocaleDateString()}</span>;
};

export const TodoListBad = () => {
  const myTodo: Todo = {
    id: "1",
    title: "Estudar SOLID",
    description: "Ler a documenta√ß√£o",
    isCompleted: false,
    createdAt: new Date(),
    userId: "user_123"
  };

  return (
    <div className="card">
      {/* Estamos for√ßando depend√™ncias desnecess√°rias aqui */}
      <TodoTitle todo={myTodo} />
      <TodoDate todo={myTodo} />
    </div>
  );
};
```

Refatorando esse c√≥digo, devemos quebrar as interfaces passando os dados necess√°rios para o componente funcionar.

```tsx
// Definimos uma interface espec√≠fica apenas para o que o componente precisa.
// Ou, neste caso simples, passamos a primitiva string diretamente.
interface TitleProps {
  title: string;
}

const TodoTitle = ({ title }: TitleProps) => {
  return <h1>{title}</h1>;
};

// Este componente s√≥ precisa de uma data, nada mais.
// Agora ele pode ser usado para exibir datas de Tarefas, Projetos ou Coment√°rios.
interface DateDisplayProps {
  date: Date;
}

const TodoDate = ({ date }: DateDisplayProps) => {
  return <span>Criado em: {date.toLocaleDateString()}</span>;
};

// Componente Principal
export const TodoListGood = () => {
  const myTodo = {
    id: "1",
    title: "Estudar SOLID",
    description: "Ler a documenta√ß√£o",
    isCompleted: false,
    createdAt: new Date(),
    userId: "user_123"
  };

  return (
    <div className="card">
      {/* Aplicando ISP: Passamos apenas o necess√°rio */}
      <TodoTitle title={myTodo.title} />
      <TodoDate date={myTodo.createdAt} />
    </div>
  );
};
```

Com essa refatora√ß√£o, o componente `TodoDate` se torna gen√©rico, ele aceita qualquer `Date` e n√£o apenas datas vindas do objeto `Todo`.

A estrutura do objeto `Todo` pode mudar, como por exemplo, o `userId` que o componente `TodoTitle` n√£o quebrar√°, pois ele n√£o depende dessa propriedade.

Olhando o `<TodoTitle title={...} />` percebemos quais dados o componente consome.

## Dependency Inversion Principle (DIP)

Nesse princ√≠pio, a ideia √© que componentes, fun√ß√µes ou m√≥dulos n√£o devem depender de implementa√ß√µes concretas, mas sim de abstra√ß√µes comuns.

Em geral, devemos focar em desacoplamento entre interfaces visuais e l√≥gica, utilizando props, hooks e servi√ßos. Evitando componente que cont√©m l√≥gica hardcoded dentro deles.

Nesse √∫ltimo exemplo, temos um componente `CreateTodo`, respons√°vel por salvar a tarefa. Ele importa um servi√ßo diretamente, criando um acomplamento, onde para mudarmos o servi√ßo seria preciso reescrever o componente. 

```tsx
// O componente depende de uma implementa√ß√£o concreta (axios + URL espec√≠fica)
import { useState } from "react";
import axios from "axios"; // Depend√™ncia direta de baixo n√≠vel

export const CreateTodoBad = () => {
  const [title, setTitle] = useState("");

  const handleSave = async () => {
    try {
      // O componente "sabe demais". Se a API mudar, o componente quebra.
      await axios.post("https://api.meuapp.com/todos", { title });
      alert("Tarefa salva!");
      setTitle("");
    } catch (error) {
      console.error(error);
    }
  };

  return (
    <div>
      <input 
        value={title} 
        onChange={(e) => setTitle(e.target.value)} 
        placeholder="Nova tarefa..." 
      />
      <button onClick={handleSave}>Salvar</button>
    </div>
  );
};
```

Aplicando o DIP ao refatorar o componente, ele n√£o define como salvar, define apenas uma abstra√ß√£o (interface de prop) que diz que uma tarefa precisa ser salva. A implementa√ß√£o real √© injetada de fora.

Para isso, primeiros definimos o contrato que o servi√ßo precisa seguir, com isso nosso componente depende da interface `ITodoService`, ao inv√©s do `axios`.

```tsx
import { useState } from "react";

// O componente recebe a abstra√ß√£o via props (Inje√ß√£o de Depend√™ncia)
interface CreateTodoProps {
  todoService: ITodoService; 
}

export const CreateTodoGood = ({ todoService }: CreateTodoProps) => {
  const [title, setTitle] = useState("");

  const handleSave = async () => {
    try {
      // O componente apenas chama o m√©todo da interface.
      // Ele n√£o sabe se vai para API, Firebase ou LocalStorage.
      await todoService.saveTodo(title);
      alert("Tarefa salva!");
      setTitle("");
    } catch (error) {
      console.error(error);
    }
  };

  return (
    <div>
      <input 
        value={title} 
        onChange={(e) => setTitle(e.target.value)} 
        placeholder="Nova tarefa..." 
      />
      <button onClick={handleSave}>Salvar</button>
    </div>
  );
};
```

Por fim, criamos a implementa√ß√£o real e injetamos no componente. 

```tsx
import axios from "axios";

// Implementa√ß√£o Concreta 1: Salva na API
const apiTodoService: ITodoService = {
  saveTodo: async (title: string) => {
    await axios.post("https://api.meuapp.com/todos", { title });
  },
};

// Implementa√ß√£o Concreta 2: Salva no LocalStorage (para testes ou modo offline)
const localTodoService: ITodoService = {
  saveTodo: async (title: string) => {
    const current = JSON.parse(localStorage.getItem("todos") || "[]");
    localStorage.setItem("todos", JSON.stringify([...current, { title }]));
  },
};

// Uso na Aplica√ß√£o
export const App = () => {
  // Podemos trocar "apiTodoService" por "localTodoService" sem tocar no componente visual!
  return (
    <div>
      <h1>Minha Lista</h1>
      <CreateTodoGood todoService={apiTodoService} />
    </div>
  );
};
```

Com essa refatora√ß√£o, nosso componente pode facilmente injetar um mock que n√£o faz chamadas reais para ser testado visualmente.

Caso o backend mude, um novo servi√ßo pode ser criado e injetado, mantendo a interface visual intacta. Pois o componente visual n√£o tem a resposabilidade de salvar os dados.

Àú
A respeito dos princ√≠pios de SOLID, seria apenas isso. Em breve, falaremos mais sobre Clean Code, pra aumentar ainda mais o seu arsenal de conhecimento e criar c√≥digos incr√≠veis.