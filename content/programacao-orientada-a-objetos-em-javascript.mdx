---
title: "Programa√ß√£o Orientada a Objetos em JavaScript"
publishedAt: "2025-06-03"
summary: "Uma introdu√ß√£o aos conceitos de POO em JavaScript: objetos, classes, encapsulamento, heran√ßa e polimorfismo."
category: "code"
language: "üáßüá∑"
image: ""
---

Essa √© uma introdu√ß√£o b√°sica de como programa√ß√£o orientada objetos funciona em JavaScript. Por ser um paradigma bem utilizado no universo JavaScript e em outras linguagens tamb√©m, acredito que seja importante saber pelo menos o b√°sico.

Em um projeto que trabalhei recentemente, com Angular (Front-end) e NestJS (Back-end). Percebi ainda mais a import√¢ncia, e decidir escrever essa introdu√ß√£o.

## O que √© Programa√ß√£o Orientada a Objetos (POO)?

POO √© um paradigma ou estilo de programa√ß√£o que organiza o c√≥digo em torno de objetos, ao inv√©s de programa√ß√£o funcional ou procedural.

Ele tem como objetivo melhorar a estrutura do c√≥digo, legibilidade, manuten√ß√£o e a reutiliza√ß√£o do c√≥digo, dividindo o c√≥digo em peda√ßos menores e reutiliz√°veis (objetos), cada peda√ßo cont√©m dados (propriedades) e comportamentos (m√©todos).

### Qual a diferen√ßa entre programa√ß√£o procedural, funcional e orientada a objetos?

A programa√ß√£o procedural √© baseada em fun√ß√µes e procedimentos, onde o c√≥digo √© executado de forma sequencial (cima para baixo), as fun√ß√µes s√£o usadas para organizar tarefas reutiliz√°veis, e os dados s√£o em sua maioria vari√°veis globais ou passado entre as fun√ß√µes.

```javascript
const numbers = [5, 8, 12, 3, 20];

let newNumbers = [];
for (let i = 0; i < numbers.length; i++) {
  newNumbers.push(numbers[i] + 2);
}

let sum = 0;
for (let i = 0; i < filteredNumbers.length; i++) {
  sum += filteredNumbers[i];
}
console.log(sum);
```

A programa√ß√£o funcional √© declarativa, descreve o que fazer, mas n√£o como fazer. Ela utiliza fun√ß√µes puras, onde as mesmas entradas sempre d√£o as mesmas sa√≠das, sem ter nada modificado fora da fun√ß√£o, trabalhando com imutabilidade sem alterar as vari√°veis.

```javascript
const numbers = [5, 8, 12, 3, 20];

const sum = numbers.map((n) => n + 2).reduce((acc, n) => acc + n, 0);

console.log(sum);
```

A programa√ß√£o orientada a objetos, agrupa os dados em classes e inst√¢ncias (objetos), usando conceitos como encapsulamento, heran√ßa e polimorfismo, tornando o c√≥digo mais modular, reutiliz√°vel e escal√°vel.

```javascript
class Nums {
  constructor(numbers) {
    this.numbers = numbers;
  }

  add(value) {
    this.numbers = this.numbers.map((n) => n + value);
    return this.numbers;
  }
}

const numbers = new Nums([5, 8, 12, 3, 20]);
const sum = processor.add(2).sum();

console.log(sum);
```

## Objetos em JavaScript

JavaScript √© baseado em objetos, onde a maioria da sua estrutura de dados e tipos s√£o definidos como objetos (strings, array, DOM, etc.).

Para criar um objeto, basta utilizar sua sintaxe literal de objeto `{}`. Esses objetos s√£o cole√ß√µes de pares chave-valor, onde os valores podem ser propriedades (vari√°veis) ou m√©todos (fun√ß√µes).

```javascript
const user = {
  name: "Danilo",
  getName: function () {
    return this.name;
  },
};
```

Em POO as vari√°veis dentro de um objetivos s√£o chamadas de propriedades, ou seja, `name` √© uma propriedade. Fun√ß√µes dentro de um objeto s√£o chamadas de m√©todos, ent√£o, `getName` √© um m√©todo.

Em JavaScript, √© poss√≠vel acessar os membros de um objeto usando a nota√ß√£o de ponto, `objeto.propriedade` ou `objeto.metodo()` ou nota√ß√£o de colchetes, `objeto["propriedade"]`. A nota√ß√£o de colchetes √© usada para acessar propriedades din√¢micas.

## Classes

Classes √© uma maneira mais organizada, estruturada e reutiliz√°vel de criar objetos com propriedades e m√©todos. Servem como um modelo para criar m√∫ltiplas inst√¢ncias de um tipo de objeto.

Objetos podem ser criados atrav√©s de fun√ß√µes construtoras e prot√≥tipo, por√©m esse m√©todo √© antigo, e a classe serve como um substituto padr√£o para se criar objetos.

Para criar uma classe √© utilizada a palavra-chave `class` com o nome do objeto come√ßando geralmente com a letra mai√∫scula.

```javascript
class Person {
  // corpo da classe
}
```

Classes podem ser declaradas usando `class NomeDaClasse{}` ou em forma de express√£o `const NomeDaClasse = class {}`. As classes n√£o podem ser acessadas antes de sua declara√ß√£o.

## Construtor

O `construtor` √© um m√©todo especial dentro de uma classe. Ele √© executado quando uma nova classe √© criada (instanciada). Ele normalmente √© usado para inicializar o estado da classe atribuindo valores as propriedades do objeto.

Ele geralmente recebe argumentos que representam os dados necess√°rios para criar uma classe espec√≠fica. Esses argumentos s√£o atribu√≠dos √†s propriedades da inst√¢ncia criada usando a palavra-chave `this.`

```javascript
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
}

const user = new Person(Jane Doe, 29);
```

Dentro do `constructor`, o `this` se refere √† nova inst√¢ncia do objeto que est√° sendo criada.

## Instanciando Objetos (new)

Para instanciar um novo objeto (criar um novo objeto) a partir de uma classe, √© utilizado a palavra-chave `new`, seguida do nome da classe e os argumentos necess√°rios para o `constructor`.

O operador `new`, cria um novo objeto vazio na mem√≥ria, define dentro do `constructor` o `this`, para apontar para esse novo objeto, executa o c√≥digo no `constructor`, inicializando o objeto com as propriedades e valores fornecidos e retorna o objeto criado.

Sempre que voc√™ criar um novo objeto utilizando a palavra-chave `new`, uma nova inst√¢ncia √© criada, mesmo que os valores passados sejam os mesmos.

```javascript
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
}

const user_01 = new Person(Jane Doe, 29);
const user_02 = new Person(Jane Doe, 29);
```

## M√©todos de uma Inst√¢ncia

Os m√©todos s√£o fun√ß√µes definidas dentro da classe, que fornecem comportamentos que manipulam as propriedades do objeto.

M√©todos s√£o definidos diretamente no corpo da classe, n√£o dentro do `construtor`, a menos que voc√™ queira criar uma nova fun√ß√£o para cada inst√¢ncia.

```javascript
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
  getName() {
    return this.name;
  }
  getAge() {
    return this.age;
  }
}
```

Os m√©todos s√£o chamados em uma inst√¢ncia espec√≠fica do objeto usando a nota√ß√£o de ponto, **instancia.metodo()**.

Os m√©todos s√£o compartilhados entre todas as suas inst√¢ncias de uma classe, o que √© melhor do que definir um m√©todo dentro de cada `construtor` de toda nova inst√¢ncia criada.

O `this` dentro de um m√©todo, se refere a inst√¢ncia espec√≠fica na qual o m√©todo est√° sendo chamado, permitindo que o m√©todo manipule as propriedades dessa classe.

## Encapsulamento

Um dos pilares do POO √© o agrupamento (encapsulamento) de propriedades e m√©todos que operam em um √∫nico objeto, protegendo as propriedades internas do acesso externo direto.

O encapsulamento serve para controlar como as propriedades s√£o acessadas e modificadas, visando garantir a integridade do objeto. Dessa forma impede que propriedades sejam manipuladas de forma inesperada, facilitando refatora√ß√µes futuras.

No JavaScript, √© poss√≠vel deixar um campo privado utilizando `#` no in√≠cio do nome da propriedade para for√ßar um errado de sintaxe. Assim essa propriedade s√≥ pode ser acessada por m√©todos dentro e n√£o fora da classe.

_√â comum no TypeScript utilizarmos a palavra-chave `private` para indicar que a propriedade √© privada._

```javascript
class Person {
  #futurAge;

  constructor(name, age) {
    this.name = name;
    this.age = age;
    this.#futurAge = age + 18;
  }

  getSecretAge() {
    return this.#futurAge;
  }
}
```

### Getters e Setters

√â comum em encapsulamento utilizar m√©todos para acessar e modificar propriedades internas. Eles ajudam a controlar os acessos e permitem valida√ß√£o, tornando o c√≥digo mais robusto.

No JavaScript existe a sintaxe `get` e `set` para criar campos de acessos que parecem propriedades, por√©m n√£o s√£o implementadas com fun√ß√µes e assim permitem l√≥gica de valida√ß√£o ou transforma√ß√£o de dados.

```javascript
class Person {
  #futurAge;

  constructor(name, age) {
    this.name = name;
    this.age = age;
    this.#futurAge = age + 18;
  }

  get secretAge() {
    return this.#futurAge;
  }

  set secretAge(newAge) {
    if (newAge > 60) {
      return console.log("You have futur age");
    }

    this.#futurAge += newAge;
  }
}

const user = new Person("John Doe", 30);
user.secretAge = 61;

conso.log(user.secretAge);
```

√â conven√ß√£o comum entre desenvolvedores utilizar um sublinhado no in√≠cio do nome das propriedades (`_nomeDaPropriedade`) para indicar que elas eram propriedades privadas, mesmo que fossem acess√≠veis externamente.

## Abstra√ß√£o

Um dos pilares do POO √© a abstra√ß√£o. O objetivo √© esconder todas a complexidade da classe, e expor apenas as funcionalidades relevantes para os usu√°rios do objeto. Assim eles podem utilizar o objeto sem precisar entender todos os detalhes de como eles funcionam internamente.

N√≥s utilizamos no JavaScript o m√©todo `getTime()` que pode ser usado sem se preocupar como a classe `Date()` funciona. Dessa forma, o nosso usu√°rio deveria ser capaz de utilizar os m√©todos da classe `Person`, sem se preocupar como ela funciona.

## Heran√ßa

Outro pilar do POO √© a Heran√ßa, que permite que uma classe herde propriedades e m√©todos de outra classe, permitindo a reutiliza√ß√£o de c√≥digo e criando relacionamentos.

Para criar uma classe que herda as propriedades e m√©todos de outra classe, √© utilizado a palavra-chave `extends`.

Uma classe criada atrav√©s de uma heran√ßa √© chamada de classe derivada. Classes derivadas herdam todos os m√©todos e propriedades p√∫blicas da classe base.

```javascript
class Player extends Person {
  // Corpo da Classe
}
```

Classes derivadas devem possuir um `constructor`, mesmo que n√£o adicionem novas propriedades. No `constructor` de uma classe derivada, deve ser chamado o `super()` antes de acessar o `this`.

O `super()` chama o `constructor` da classe base e inicializa o `this` com as propriedades e m√©todos da classe base. Os argumentos passados no `super()` s√£o passados para `constructor` da classe base.

```javascript
class Player extends Person {
  constructor(name, age, team) {
    super(name, age);
    this.team = team;
  }
}
```

M√©todos est√°ticos tamb√©m s√£o herdados pela classe derivada, e essas classes derivadas n√£o t√™m acesso direto aos campos privados da classe base.

A palavra-chave `super` tamb√©m pode ser usado em m√©todos de classe derivada para acessar m√©todo da classe base, permitindo estender ou modificar o comportamento herdado sendo duplicar c√≥digo.

## Polimorfismo

Um dos pilares do POO, Polimorfismo, se refere √† capacidade de objetos de diferentes classes responderem ao mesmo m√©todo de maneira diferente, ou seja, um m√©todo pode se comportar de forma diferente dependendo do tipo de objeto em que ele √© chamado.

Se uma classe derivada sobrescreve o m√©todo da classe base, o m√©todo chamado depender√° do tipo real do objeto. Por exemplo, suponhamos que na nossa classe `Person` e `Player` existem os m√©todos `Welcome()`, em uma inst√¢ncia de `Person`, o m√©todo `Welcome()` executar√° a vers√£o de `Person`, e na de `Player` a vers√£o de `Player` caso ela seja sobrescrita.

## Propriedades p√∫blicas

Permitem criar propriedades diretamente no corpo da classe, usado geralmente para valores que n√£o dependem diretamente de um argumento do construtor ou para definir valores padr√µes.

```javascript
class Game {
  randomNumber = Math.random();
}
```

## Propriedades est√°ticas

Propriedades que s√£o definidos com a palavra-chave `static` pertencem √† classe em si, e n√£o h√° uma inst√¢ncia individual. Elas s√£o acessadas diretamente no nome da classe.

Geralmente s√£o usadas como propriedades ou m√©todos utilit√°rios relevantes para a classe como um todo ao inv√©s de uma inst√¢ncia espec√≠fica.

```javascript
class Company {
  static brandColor = "#fb5634";
}
```

## Tipos Primitivos vs Tipos de Refer√™ncia

Tipos primitivos como: `number, string, boolean, symbol, undefined e null`, s√£o armazenados diretamente na vari√°vel e copiados por valor.

Tipos de refer√™ncia como: `object, function, array`, s√£o armazenados na mem√≥ria e a vari√°vel armazena a refer√™ncia (o endere√ßo na mem√≥ria) daquele objeto, ou seja, s√£o copiados por refer√™ncia.

Quando um tipo primitivo √© copiado, uma nova c√≥pia do valor √© criada, sendo assim quando uma vari√°vel √© alterada ela n√£o afeta a outra.

Quando um tipo de refer√™ncia √© copiado, a refer√™ncia √© copiada tamb√©m e ambas apontam para o mesmo objeto na mem√≥ria, ou seja, ao alterar esse objeto em uma vari√°vel, outra vari√°vel tamb√©m √© alterada.

Ao passar um tipo primitivo para uma fun√ß√£o, o valor √© copiado para o par√¢metro local, e as altera√ß√µes nesse par√¢metro local n√£o afeta a vari√°vel original.

A passar um tipo de refer√™ncia para uma fun√ß√£o, a refer√™ncia √© copiada, e as altera√ß√µes no objeto atrav√©s do par√¢metro local afetam o objeto original.

## Conclus√£o

Com isso, voc√™ agora tem uma base de como programa√ß√£o orientada a objetos funcionam no JavaScript. Agora √© colocar esse conhecimento em pr√°tica e se aprofundar cada vez mais.
